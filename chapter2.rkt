#lang racket
(require rackunit)

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
(define (abs x)
  (cond ((>= x 0) x)
        (else (- x))))

(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) (/ d g))))
(define (numer x) (car x))
(define (denom x) (cdr x))
(define (print-rat x)
  (newline)
  (display (numer x))
  (display "/")
  (display (denom x)))

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
(define x (cons 1 2))
(define y (cons 3 4))
(define z (cons x y))
(test-case
 "2.1.1 Pairs"
 (check-eq? (car x) 1)
 (check-eq? (cdr x) 2)
 (check-eq? (car (car z)) 1)
 (check-eq? (car (cdr z)) 3))

(define one-half (make-rat 1 2))
(print-rat one-half)
(define one-third (make-rat 1 3))
(print-rat (add-rat one-half one-third))
(print-rat (mul-rat one-half one-third))
(print-rat (add-rat one-third one-third))

(define (make-rat-norm n d)
  (cond ((and (> n 0) (> d 0))
         (make-rat n d))
        ((and (< n 0) (< d 0))
         (make-rat (- n) (- d)))
        (else (make-rat (- (abs n)) (abs d))))) 
(test-case
 "Exercise 2.1"
 (check-eq? (equal-rat? (make-rat-norm 1 2) one-half) true)
 (check-eq? (equal-rat? (make-rat-norm (- 1) (- 2)) one-half) true)
 (check-eq? (equal-rat? (make-rat-norm (- 1) 2) (make-rat (- 1) 2)) true)
 (check-eq? (equal-rat? (make-rat-norm 1 (- 2)) (make-rat (- 1) 2)) true))
 
(define (make-point x y)
  (cons x y))
(define (x-point x)
  (car x))
(define (y-point y)
  (cdr y))
(define (make-segment w x y z)
  (cons (make-point w x) (make-point y z)))
(define (start-segment x)
  (car x))
(define (end-segment x)
  (cdr x))
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
(define (average x y f)
  (/ (+ (f x) (f y)) 2))
  
(define (midpoint-segment s)
  (make-point (average (start-segment s) (end-segment s) x-point)
              (average (start-segment s) (end-segment s) y-point)))
(print-point (midpoint-segment (make-segment 0 0 10 10)))

;(define (element-of-set? x set)
;  (cond ((null? set) false)
;        ((= x (car set)) true)
;        ((< x (car set)) false)
;        (else (element-of-set? x (cdr set)))))
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1
                     (intersection-set (cdr set1)
                                       (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) false)
        ((= x (entry set)) true)
        ((< x (entry set))
         (element-of-set? x (left-branch set)))
        ((> x (entry set))
         (element-of-set? x (right-branch set)))))
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set))
         (make-tree (entry set)
                    (adjoin-set x (left-branch set))
                    (right-branch set)))
        ((> x (entry set))
         (make-tree (entry set)
                    (left-branch set)
                    (adjoin-set x (right-branch set))))))